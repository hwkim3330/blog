아키텍처 심층 분석 및 구현 가이드: Microchip LAN966x/LAN969x TSN 스위치 리눅스 배포섹션 1: 요약 및 아키텍처 개요1.1. 핵심 질문에 대한 직접적인 답변본 보고서는 Microchip의 LAN966x 및 LAN969x 시리즈 개발 보드에 대한 리눅스 시스템 구축 및 배포 방법을 심층적으로 다룹니다. 사용자의 핵심 질문에 대한 답변은 다음과 같습니다.자체 eMMC 플래시 탑재 여부: 예, LAN966x 제품군의 독립형(Standalone) 평가 보드, 특히 EVB-LAN9662는 운영체제 저장을 위한 4GB eMMC NAND 플래시를 내장하고 있습니다.1 이는 보드가 외부 저장 장치 없이 자체적으로 완전한 리눅스 시스템을 부팅하고 운영할 수 있음을 의미합니다.리눅스 설치 방법: 임베디드 시스템의 특성상, 일반적인 데스크톱 PC와 같은 대화형 설치 과정은 존재하지 않습니다. 대신, 개발자는 호스트 PC(주로 Ubuntu)에서 크로스 컴파일(cross-compilation)을 통해 전체 시스템 이미지를 빌드합니다. 이 생성된 이미지를 보드의 부트로더(U-Boot)를 통해 네트워크(TFTP)로 전송한 후, 내장된 eMMC 플래시에 "플래싱(flashing)"하는 방식으로 시스템을 배포합니다.2 따라서 '설치'는 '이미지 빌드 및 플래싱'의 워크플로우를 의미합니다.1.2. LAN966x 및 LAN969x SoC 제품군 소개Microchip의 LAN966x 및 LAN969x는 산업 자동화 및 자동차 네트워킹을 위해 설계된 고성능 이더넷 스위치 SoC(System-on-Chip) 제품군입니다. 이들은 단순한 스위칭 기능을 넘어, 내장된 Arm CPU 코어를 통해 독립적인 임베디드 시스템으로 동작할 수 있는 능력을 갖추고 있습니다.LAN9662: 이 디바이스는 600 MHz Arm Cortex-A7 CPU 서브시스템을 통합한 비용 효율적인 멀티포트 기가비트 이더넷 스위치입니다.3 주요 특징은 TSN(Time-Sensitive Networking) 기능으로, PROFINET, OPC UA와 같은 실시간 산업용 이더넷 프로토콜을 하드웨어 수준에서 가속화하는 데 최적화되어 있습니다.5 특히 Real-Time Engine (RTE)을 통해 PROFINET의 순환 데이터 프레임을 하드웨어 오프로드하여 CPU 부하를 크게 줄이고 결정론적(deterministic) 통신을 보장합니다.3LAN969x (LAN9691, LAN9692, LAN9693 포함): LAN969x 제품군은 LAN966x의 상위 모델로, 더 높은 성능과 확장성을 제공합니다. 1GHz 단일 코어 Arm Cortex-A53 CPU를 탑재하여 연산 능력이 향상되었으며, 최대 102Gbps에 이르는 더 높은 대역폭과 더 많은 포트 수를 지원합니다.7 이 제품군은 고성능 산업 자동화뿐만 아니라 차세대 자동차의 도메인 컨트롤러, 존(zone) 아키텍처 등에서 요구하는 엄격한 TSN 및 보안 요구사항을 충족하도록 설계되었습니다.81.3. 통합된 개발 경로의 이해사용자가 질의한 LAN9662와 LAN9692는 각각 다른 SoC이지만, Microchip은 이 두 제품군에 걸쳐 일관되고 확장 가능한 개발 경험을 제공하기 위한 전략을 채택했습니다. 두 제품군은 CPU 코어(Cortex-A7 vs. Cortex-A53)와 스위치 성능에서 차이가 있지만, 근본적인 소프트웨어 아키텍처와 개발 생태계를 공유합니다.12이러한 접근 방식의 핵심은 공통된 보드 지원 패키지(Board Support Package, BSP)에 있습니다. 개발자는 동일한 Buildroot 기반의 BSP와 부트 아키텍처(ARM Trusted Firmware, TF-A)를 사용하여 두 제품군 모두를 위한 리눅스 시스템을 빌드할 수 있습니다. 이는 LAN9662로 개발을 시작한 엔지니어가 더 높은 성능이 필요하여 LAN969x로 마이그레이션할 때, 기존의 소프트웨어 자산과 개발 지식을 거의 그대로 재사용할 수 있음을 의미합니다. 개발 프로세스의 유사성은 학습 곡선을 최소화하고 제품 개발 시간을 단축시키는 중요한 이점을 제공합니다. 따라서 본 보고서는 상대적으로 문서화가 풍부한 LAN9662를 기준으로 상세한 절차를 설명하고, LAN969x에 적용하기 위해 필요한 최소한의 변경 사항을 안내하는 방식으로 구성하여 개발자에게 보다 효율적인 학습 경로를 제시합니다.섹션 2: 하드웨어 플랫폼 분석: 평가 보드와 저장 장치Microchip은 LAN966x 및 LAN969x SoC의 기능을 평가하고 개발을 가속화하기 위해 다양한 형태의 평가 보드를 제공합니다. 각 보드는 특정 사용 사례에 맞춰 설계되었으므로, 개발 목표에 맞는 보드를 선택하는 것이 중요합니다.2.1. 독립형 평가 보드: EVB-LAN9662EVB-LAN9662는 LAN9662 SoC를 위한 핵심적인 독립형(standalone) 평가 플랫폼입니다.14 이 보드는 LAN9662의 내장 CPU를 활용하여 완전한 임베디드 리눅스 시스템을 구동하는 것을 목표로 설계되었습니다. 공식 문서에 따르면 주요 하드웨어 사양은 다음과 같습니다 1:SoC: LAN9662 (600 MHz Arm Cortex-A7 CPU 통합)DRAM: 512MB DDR3L RAM (보드 버전에 따라 1GB 또는 2GB 옵션 가능)부트 플래시: SST26VF016B SPI NOR 플래시 (일반적으로 16Mbit / 2MB, 부트로더 저장용)주 저장 장치: 4GB eMMC NAND 플래시 (리눅스 루트 파일 시스템 및 사용자 애플리케이션 저장용)인터페이스: 2개의 10/100/1000BASE-T RJ45 포트, USB 2.0 호스트, 콘솔 통신을 위한 직렬 포트 14이 보드는 자체 프로세서, 메모리, 저장 장치를 모두 갖추고 있어 외부 제어 장치 없이 단독으로 동작하며, 임베디드 스위치 애플리케이션을 개발하고 테스트하는 데 가장 적합한 환경을 제공합니다.2.2. 모듈형/주변 장치형 평가 보드: NIC 및 캐리어모든 개발 시나리오가 독립형 시스템을 요구하는 것은 아닙니다. 기존의 강력한 호스트 프로세서에 LAN9662의 TSN 스위칭 기능만 추가하고자 하는 경우를 위해 Microchip은 다른 형태의 보드를 제공합니다.EVB-LAN9662-NIC: 이 보드는 LAN9662를 표준 PCIe 네트워크 인터페이스 카드(NIC) 형태로 제공합니다.16 가장 중요한 차이점은 보드에 DDR 메모리가 없다는 것입니다.18 따라서 이 보드는 자체적으로 리눅스 OS를 실행할 수 없으며, 반드시 호스트 시스템(예: 데스크톱 PC 또는 다른 임베디드 보드)의 PCIe 슬롯에 장착되어 호스트의 제어를 받아야 합니다. 이 보드의 목적은 LAN9662를 스위칭 코프로세서로 활용하는 소프트웨어를 개발하는 것입니다.EVB-LAN9662-Carrier: 캐리어 보드는 EVB-LAN9662 CPU 보드와 함께 사용되는 I/O 확장 보드입니다.19 이 보드는 EVB-LAN9662를 장착하여 독립형으로 사용하거나, Raspberry Pi Compute Module 4 (CM4)와 같은 외부 CPU 모듈을 장착하여 LAN9662를 PCIe 주변 장치로 제어하는 등 다양한 구성이 가능하도록 유연성을 제공합니다.20 또한, SFP 케이지를 제공하여 구리, 광, DAC 등 다양한 물리 계층 연결을 평가할 수 있습니다.192.3. LAN969x 평가 보드 제품군LAN969x 제품군 역시 다양한 평가 보드를 통해 지원됩니다. 대표적으로 자동차용 12포트 EVB (EV09P11A/2)와 산업용 24포트 EVB (EV23X71A)가 있습니다.7 이 보드들의 문서에서 eMMC 용량이 명시적으로 언급되지는 않지만, SoC 자체가 eMMC 부팅을 지원하며 22, 특히 24포트 EVB의 사양에 "리눅스를 실행하는 내부 CPU (Internal CPU running Linux)"가 명시된 점 8은 독립적인 운영을 위한 eMMC가 내장되어 있음을 강력히 시사합니다. 이는 EVB-LAN9662의 설계 패턴을 따르는 표준 구성으로 볼 수 있습니다.이처럼 Microchip의 하드웨어 생태계는 고객의 다양한 요구사항을 충족시키기 위해 의도적으로 모듈화되어 있습니다. 첫째, SoC를 중심으로 완전한 독립 시스템을 평가하고 개발하려는 고객과, 둘째, 기존 호스트 시스템에 TSN 스위칭 기능만 추가하려는 고객 모두를 지원합니다. 따라서 "리눅스 설치"라는 개념은 선택한 보드에 따라 근본적으로 달라집니다. 본 보고서에서 다루는 내용은 사용자의 질의 의도에 가장 부합하는 독립형 EVB-LAN9662 보드에서 Cortex-A7용 시스템 이미지를 빌드하고 플래싱하는 가장 포괄적인 시나리오에 초점을 맞춥니다.2.4. LAN966x/LAN969x 평가 보드 하드웨어 사양 비교다음 표는 주요 평가 보드 간의 핵심적인 하드웨어 차이점을 요약하여 개발자가 자신의 요구에 맞는 플랫폼을 쉽게 식별할 수 있도록 돕습니다.보드 이름부품 번호SoCCPU 코어DDR RAMSPI NOR 플래시eMMC NAND 플래시주요 사용 사례EVB-LAN9662EV09D37ALAN9662Arm Cortex-A7 @ 600MHz512MB DDR3L2MB4GB독립형 TSN 스위치 시스템 개발 및 평가 1EVB-LAN9662-NICEV53U25ALAN9662Arm Cortex-A7 (사용 불가)없음부팅용 SPI없음호스트 시스템용 PCIe TSN 네트워크 카드 개발 17EVB-LAN9662-CarrierEV44Z97A-----EVB-LAN9662 또는 RPi CM4용 I/O 확장 19LAN9692 Automotive EVBEV09P11A/2LAN9692Arm Cortex-A53 @ 1GHz내장내장내장 (추정)자동차용 고성능 TSN 스위치 개발 10LAN969x 24-port EVBEV23X71ALAN969xArm Cortex-A53 @ 1GHz내장내장내장 (추정)산업용 고포트 수 TSN 스위치 개발 7섹션 3: 소프트웨어 생태계: BSP, 툴체인, 그리고 부트 프로세스Microchip LAN966x/LAN969x 기반의 임베디드 리눅스 시스템을 개발하기 위해서는 하드웨어만큼이나 소프트웨어 생태계에 대한 깊은 이해가 필수적입니다. 이 생태계의 핵심은 BSP, 보안 부트 아키텍처, 그리고 U-Boot 부트로더로 구성됩니다.3.1. Microchip UNG 보드 지원 패키지 (BSP)BSP는 특정 하드웨어를 지원하는 데 필요한 코드와 설정 항목들을 모아놓은 소프트웨어 패키지의 기초입니다.23 Microchip의 UNG(Unified Networking Group) BSP는 LAN966x/LAN969x 개발의 중심축 역할을 합니다.이 BSP의 가장 큰 특징은 Buildroot를 기반으로 한다는 점입니다.25 Buildroot는 크로스 컴파일을 통해 완전한 임베디드 리눅스 시스템을 생성하는 간단하고 효율적인 도구입니다. 개발자는 Buildroot가 제공하는 Kconfig 기반의 설정 메뉴를 통해 커널, 부트로더, 필요한 라이브러리 및 사용자 애플리케이션을 선택하기만 하면, Buildroot가 나머지 복잡한 빌드 과정을 자동화합니다. 이는 '설치'가 아닌 '빌드' 중심의 개발 워크플로우를 명확히 보여줍니다.관련 리소스는 온라인으로 제공됩니다. BSP 문서는 GitHub Pages(https://microchip-ung.github.io/bsp-doc/)를 통해 열람할 수 있으며 23, BSP 소스 패키지(tar.gz 파일)는 Microchip이 운영하는 S3 서버에서 다운로드할 수 있습니다.183.2. 보안 부트 아키텍처: 다단계 부팅 과정최신 Armv8 SoC의 특징 중 하나는 보안을 강화하기 위한 복잡하고 계층적인 부트 프로세스입니다. LAN966x/LAN969x는 ARM 신뢰 펌웨어(Trusted Firmware for ARM, TF-A) 아키텍처를 기반으로 하며, 이는 개발자가 반드시 이해해야 할 핵심 개념입니다.27 기존의 부트로더 -> 커널 방식의 단순한 시퀀스와는 근본적으로 다릅니다.TF-A/BL1 (ROM 코드): 부팅의 가장 첫 단계로, SoC 내부에 고정된 변경 불가능한 ROM 코드입니다. 전원이 인가되면 가장 먼저 실행되며, 하드웨어 스트래핑 핀 설정을 읽어 부팅할 매체(eMMC, SPI NOR 등)를 결정하고 다음 단계의 부트로더(BL2)를 로드합니다.27TF-A/BL2 (2단계 부트로더): BL1에 의해 로드되어 칩 내부의 SRAM에서 실행됩니다. DDR 메모리 컨트롤러 초기화, TrustZone(보안/비보안 영역 분리) 설정과 같은 핵심적인 플랫폼 초기화를 수행합니다.27펌웨어 이미지 패키지 (FIP): BL2는 이후의 부트 구성 요소들을 FIP (Firmware Image Packet) 라는 단일 파일에서 로드합니다. FIP는 U-Boot, TF-A 런타임 등 여러 바이너리를 하나의 패키지로 묶고 서명하여, 부팅 과정의 무결성을 보장하는 컨테이너 역할을 합니다.27TF-A/BL31 (EL3 런타임 소프트웨어): 보안 모니터로서, 시스템이 부팅된 후에도 메모리에 상주하며 보안 세계(Secure World)와 비보안 세계(Normal World) 간의 전환을 관리하는 역할을 합니다.27TF-A/BL33 (비보안 펌웨어): 이 단계가 바로 개발자가 주로 다루게 될 U-Boot가 위치하는 곳입니다. TF-A의 보안 부팅 과정이 완료된 후, 비보안 세계에서 실행되어 리눅스 커널을 로드하는 임무를 수행합니다.27이러한 계층적 구조는 시스템의 보안을 강화하지만, 개발자는 자신의 코드가 이 정해진 프레임워크 안에서 동작해야 함을 인지해야 합니다. 예를 들어, 단순히 U-Boot 바이너리를 교체하는 것이 아니라, 새로운 U-Boot를 포함하는 FIP 파일을 생성하고 이를 플래싱해야 합니다.3.3. U-Boot: 비보안 세계의 부트로더U-Boot는 TF-A의 보안 시퀀스 이후에 제어권을 넘겨받는 오픈소스 부트로더입니다. U-Boot의 주된 역할은 저장 장치(eMMC)에서 리눅스 커널 이미지(.itb 파일)를 읽어 DDR RAM으로 로드한 뒤, 커널에 시스템 제어권을 넘기는 것입니다.27개발자에게 U-Boot는 매우 중요한 인터페이스입니다. 직렬 콘솔을 통해 U-Boot 프롬프트에 접근할 수 있으며, 이를 통해 네트워크 설정, TFTP를 이용한 이미지 다운로드, eMMC/SPI 플래시 읽기/쓰기 등 시스템 배포 및 디버깅에 필요한 거의 모든 저수준 작업을 수동으로 수행할 수 있습니다.23.4. 개발 환경 및 툴체인LAN966x/LAN969x용 리눅스 시스템을 빌드하기 위해서는 적절한 개발 환경 구축이 선행되어야 합니다.호스트 환경: Microchip의 공식 가이드에서는 Ubuntu Linux PC 사용을 권장하며, 구체적으로 Ubuntu 22.04 LTS가 언급된 예시가 있습니다.2크로스 컴파일러 툴체인: 개발은 x86 아키텍처의 PC에서 이루어지지만, 최종 결과물은 Arm 아키텍처의 보드에서 실행되어야 합니다. 이를 위해 Arm용 실행 파일을 생성할 수 있는 크로스 컴파일러 툴체인이 필요합니다. 다행히 Buildroot 기반의 BSP는 이 과정을 자동화하여, 빌드 시점에 필요한 버전의 툴체인을 자동으로 다운로드하고 설정해 줍니다.6섹션 4: Microchip BSP를 이용한 독립형 리눅스 이미지 빌드이 섹션에서는 Microchip의 Buildroot 기반 BSP를 사용하여 EVB-LAN9662 보드에서 독립적으로 실행될 리눅스 시스템 이미지를 빌드하는 전체 과정을 단계별로 상세히 설명합니다.4.1. 전제 조건 및 환경 설정빌드를 시작하기 전에 호스트 PC에 필요한 개발 환경을 구축해야 합니다.필수 패키지 설치: Ubuntu 호스트 시스템에서 터미널을 열고 다음 명령어를 실행하여 빌드에 필요한 기본 도구들을 설치합니다. 이 패키지들은 컴파일러, 빌드 자동화 도구, 커널 설정 도구 등을 포함합니다.29Bashsudo apt-get update
sudo apt-get install git build-essential gcc make libncurses5-dev bc bison flex libssl-dev
BSP 소스 코드 다운로드: Microchip의 공식 배포처에서 최신 버전의 BSP 소스 코드 압축 파일(mscc-brsdk-source-*.tar.gz)을 다운로드합니다.2Bash# 예시: 2023.09-1 버전 다운로드
wget http://mscc-ent-open-source.s3-eu-west-1.amazonaws.com/public_root/bsp/mscc-brsdk-source-2023.09-1.tar.gz
4.2. Buildroot 시스템 설정다운로드한 소스 코드를 기반으로 빌드 환경을 구성합니다.소스 코드 압축 해제: 다운로드한 파일의 압축을 해제합니다.Bashtar -xzf mscc-brsdk-source-2023.09-1.tar.gz
cd mscc-brsdk-source-2023.09-1
기본 설정(defconfig) 적용: Buildroot는 다양한 타겟 보드를 지원하며, 각 보드에 맞는 기본 설정 파일(defconfig)을 제공합니다. make 명령을 사용하여 EVB-LAN9662 독립형 보드에 맞는 설정을 로드합니다. O= 옵션은 빌드 결과물이 소스 코드와 분리된 별도의 디렉토리에 생성되도록 지정합니다.Bash# 'my_build'라는 출력 디렉토리를 사용하고, lan966x 독립형 보드 설정을 로드
make O=my_build lan966x_standalone_defconfig
세부 설정 메뉴 진입: make menuconfig 명령을 실행하면 텍스트 기반의 설정 인터페이스가 나타납니다. 이곳에서 개발자는 커널 버전 변경, 부트로더 옵션 수정, 파일 시스템에 포함할 추가적인 사용자 공간 패키지(예: iperf, python) 선택, 시스템 구성 변경 등 매우 세부적인 커스터마이징을 수행할 수 있습니다.2Bashcd my_build
make menuconfig
설정이 완료되면, 메뉴를 종료하면서 변경 사항을 저장합니다. 초기 테스트 단계에서는 기본 설정을 그대로 사용하는 것이 권장됩니다.4.3. 빌드 프로세스 시작모든 설정이 완료되면, make 명령 하나로 전체 빌드 프로세스를 시작할 수 있습니다.Bashmake
이 명령이 실행되면 Buildroot는 다음과 같은 복잡한 작업들을 자동으로 수행합니다:필요한 버전의 크로스 컴파일러 툴체인 다운로드 및 빌드U-Boot 소스 코드 다운로드, 패치 적용 및 컴파일리눅스 커널 소스 코드 다운로드, 패치 적용 및 컴파일menuconfig에서 선택된 모든 사용자 공간 패키지 및 라이브러리 다운로드 및 컴파일모든 결과물을 조합하여 최종 루트 파일 시스템 이미지 생성이 과정은 호스트 PC의 성능과 인터넷 속도에 따라 수십 분에서 수 시간까지 소요될 수 있습니다.2 Buildroot의 강력함은 이 모든 과정을 자동화하여 개발자가 고수준의 시스템 구성에만 집중할 수 있도록 해준다는 점에 있습니다.4.4. 빌드 결과물 확인빌드가 성공적으로 완료되면, 지정한 출력 디렉토리(my_build/images/) 내에 여러 결과 파일이 생성됩니다.2 이 중 시스템 배포에 사용될 가장 중요한 파일은 다음과 같습니다.brsdk_standalone_arm.ext4.gz: 이것이 바로 보드의 eMMC에 플래싱할 최종 이미지 파일입니다. 내부에 리눅스 커널, 디바이스 트리, 그리고 ext4 형식의 루트 파일 시스템이 모두 포함된 압축 파일입니다.2fip.bin: TF-A 부트 아키텍처에서 사용되는 펌웨어 이미지 패키지입니다. U-Boot 바이너리 등이 포함되어 있으며, 부트로더 업데이트 시 사용될 수 있습니다.28기타: U-Boot, 커널, 디바이스 트리 등의 개별 바이너리 파일들도 생성되지만, 일반적인 배포에는 ext4.gz 이미지를 사용합니다.이 빌드 과정을 통해 개발자는 수동으로 커널이나 부트로더를 컴파일하는 번거로움 없이, menuconfig를 통한 고수준 설정만으로 완전한 임베디드 리눅스 시스템을 얻을 수 있습니다. 이는 프로젝트의 재현성을 높이고 장기적인 유지보수를 용이하게 하는 핵심적인 장점입니다.섹션 5: 시스템 배포 및 플래싱 절차빌드된 리눅스 이미지를 실제 하드웨어에 배포하는 것은 임베디드 개발의 핵심 단계입니다. Microchip LAN966x 시스템은 개발 중 빠른 반복 작업을 위한 방법과, 시스템이 부팅 불능 상태에 빠졌을 때를 대비한 복구 방법을 모두 제공하여 안정적인 개발 환경을 보장합니다.5.1. 하드웨어 준비 및 콘솔 연결플래싱을 시작하기 전에 물리적인 연결과 호스트 PC 설정을 완료해야 합니다.콘솔 연결: USB-to-Serial 변환기를 사용하여 호스트 PC와 EVB-LAN9662 보드의 콘솔 포트를 연결합니다. 이는 부트 프로세스를 모니터링하고 U-Boot 프롬프트와 상호작용하기 위해 필수적입니다. 직렬 터미널 프로그램(예: TeraTerm, Minicom)의 설정은 **115200 baud, 8 데이터 비트, 패리티 없음, 1 스톱 비트 (8-N-1)**로 맞춥니다.2부트 모드 설정 (하드웨어 스트래핑): EVB-LAN9662는 특정 핀(VCORE)의 전압 레벨을 통해 부트 모드를 결정합니다. 이 스트래핑 설정은 보드가 어디에서 부트로더를 읽어올지 지정하는 가장 중요한 하드웨어 단계입니다. 핀을 점퍼나 스위치로 설정하여 원하는 모드를 선택합니다.2VCORE 스트래핑 값부트 모드설명0b0000eMMC 부팅기본 부팅 모드. eMMC에서 부트로더를 로드합니다. 20b0001SPI NOR 부팅SPI NOR 플래시에서 부트로더를 로드합니다. 20b0010모니터 모드 (UART)TF-A UART 모니터를 활성화하여 시스템 복구에 사용합니다. 28TFTP 서버 설정: 호스트 PC에 TFTP 서버를 설치하고 실행합니다. 이전 단계에서 빌드한 brsdk_standalone_arm.ext4.gz 이미지 파일을 TFTP 서버의 루트 디렉토리에 복사합니다. 호스트 PC의 IP 주소는 고정 IP로 설정하는 것이 편리합니다.25.2. 주 배포 방법: U-Boot와 TFTP를 이용한 플래싱이 방법은 정상적으로 U-Boot가 동작하는 상태에서 개발 중인 이미지를 빠르고 반복적으로 업데이트할 때 사용됩니다.U-Boot 프롬프트 진입: 보드의 스트래핑을 eMMC 부팅(0b0000)으로 설정하고 전원을 켭니다. 직렬 콘솔에 부팅 메시지가 나타나면, 카운트다운이 끝나기 전에 아무 키나 눌러 자동 부팅을 중단하고 U-Boot 프롬프트(m =>)로 진입합니다.2U-Boot 네트워크 설정: U-Boot가 TFTP 서버와 통신할 수 있도록 네트워크 환경 변수를 설정합니다. ipaddr는 보드에 할당할 IP, serverip는 TFTP 서버(호스트 PC)의 IP입니다.2Code snippetm => setenv ipaddr 192.168.1.98
m => setenv serverip 192.168.1.2
m => setenv netmask 255.255.255.0
m => saveenv  # 설정을 플래시에 저장
이미지 다운로드: tftp 명령을 사용하여 TFTP 서버에서 이미지 파일을 보드의 DDR RAM으로 다운로드합니다. loadaddr는 U-Boot에 사전 정의된 RAM 주소 변수입니다.Code snippetm => tftp ${loadaddr} brsdk_standalone_arm.ext4.gz
콘솔에 Bytes transferred =... 메시지가 표시되면 다운로드가 성공한 것입니다.2이미지 압축 해제: 다운로드한 .gz 파일의 압축을 RAM의 다른 위치에 해제합니다. unzip 명령과 사전 정의된 주소 변수(mmc_unzip_loadaddr)를 사용합니다.Code snippetm => unzip ${loadaddr} ${filesize} ${mmc_unzip_loadaddr}
eMMC에 쓰기: mmc write 명령을 사용하여 RAM에 압축 해제된 이미지 데이터를 eMMC 플래시에 씁니다. 명령어의 파라미터는 (RAM 소스 주소), (eMMC 시작 블록), (쓸 블록 개수) 순서입니다.Code snippet# ${filesize_unzip_blk}는 unzip 명령 후 계산된 블록 크기 변수
m => mmc write ${mmc_unzip_loadaddr} 0 ${filesize_unzip_blk}
... blocks written: OK 메시지가 나타나면 플래싱이 완료된 것입니다.27재부팅 및 확인: 보드를 리셋(reset 명령)하면, 이제 eMMC에 새로 플래싱된 리눅스 시스템으로 부팅됩니다.5.3. 복구 방법: TF-A 모니터를 이용한 이미지 복원이 방법은 U-Boot가 손상되거나 eMMC 파티션이 잘못되어 정상 부팅이 불가능한 '벽돌(bricked)' 상태의 보드를 복구하기 위한 최후의 수단입니다.모니터 모드 진입: 보드의 하드웨어 스트래핑을 '모니터 모드'(0b0010)로 변경합니다.28웹 기반 복구 도구 사용: 호스트 PC에서 Chrome 또는 Edge 브라우저를 열고, BSP 빌드 결과물에 포함된 fwu.html 파일을 엽니다. 이 웹 애플리케이션은 Web Serial API를 사용하여 보드와 직접 통신합니다.28복구 절차: fwu.html 페이지의 안내에 따라 다음 절차를 수행합니다.버튼을 눌러 보드의 직렬 포트에 연결합니다.연결이 성공하면, BL2U라는 특수 업데이트용 부트로더를 보드로 다운로드합니다.이후 웹 UI를 통해 완전한 시스템 이미지(.gpt 파일) 또는 부트로더 패키지(.fip 파일)를 호스트 PC에서 선택하여 보드의 eMMC 또는 SPI NOR 플래시로 직접 라이팅할 수 있습니다.28이 두 가지 계층적인 배포 전략은 개발자에게 큰 안정감을 줍니다. U-Boot/TFTP 방식은 일상적인 개발 사이클의 속도를 높여주고, TF-A 모니터 방식은 실수가 발생하더라도 고가의 개발 보드를 영구적으로 손상시킬 위험 없이 안전하게 복구할 수 있는 강력한 안전망을 제공합니다.5.4. U-Boot 이미지 플래싱 주요 명령어 참조명령어구문 / 예시설명setenvsetenv <변수> <값>환경 변수를 설정합니다. (예: setenv ipaddr 192.168.1.98) 2saveenvsaveenv현재 환경 변수 설정을 플래시 메모리에 영구 저장합니다. 2tftptftp <RAM 주소> <파일명>TFTP를 통해 파일을 지정된 RAM 주소로 다운로드합니다. 27dhcpdhcp <RAM 주소> <파일명>DHCP로 IP를 할당받은 후 TFTP로 파일을 다운로드합니다. 27unzipunzip <소스 주소> <크기> <목표 주소>RAM에 있는 gzip 압축 파일을 다른 RAM 주소에 해제합니다. 2mmc infommc infoeMMC 장치 정보를 표시합니다.mmc partmmc parteMMC의 파티션 테이블을 표시합니다.mmc writemmc write <RAM 주소> <블록 시작> <블록 수>RAM의 데이터를 eMMC의 지정된 위치에 씁니다. 27resetreset보드를 재부팅합니다.섹션 6: 설치 이후: 시스템 상호작용 및 추가 개발리눅스 이미지를 성공적으로 보드에 플래싱했다면, 이제 시스템과 상호작용하고 애플리케이션을 개발할 차례입니다. Microchip은 표준 리눅스 인터페이스와 자체 제공 API를 모두 지원하여 다양한 수준의 제어를 가능하게 합니다.6.1. 첫 부팅 및 시스템 접근로그인: 플래싱 후 보드가 재부팅되면, 직렬 콘솔을 통해 리눅스 부팅 로그가 출력되는 것을 확인할 수 있습니다. 부팅이 완료되면 로그인 프롬프트가 나타납니다. 기본 사용자 계정은 root이며, 비밀번호는 없습니다.18기본 시스템 확인: 로그인 후, 표준 리눅스 명령어를 사용하여 시스템이 정상적으로 동작하는지 확인합니다.ip a 또는 ifconfig -a: 시스템이 인식한 네트워크 인터페이스 목록을 확인합니다. LAN9662의 이더넷 포트들이 eth0, eth1 등으로 나타나야 합니다.21dmesg: 커널 부팅 메시지를 확인하여 하드웨어 드라이버가 정상적으로 로드되었는지 검토할 수 있습니다.lspci: 만약 보드가 PCIe 모드로 동작 중이라면, 이 명령어로 PCIe 장치가 인식되었는지 확인할 수 있습니다.186.2. 스위치 패브릭 제어: SwitchdevMicrochip은 최신 리눅스 커널의 표준 드라이버 모델인 switchdev를 지원합니다. switchdev는 커널의 네트워킹 스택(브리지, 라우팅 등)이 스위치 하드웨어의 오프로딩 기능을 직접 제어할 수 있도록 하는 프레임워크입니다.25 이는 개발자가 복잡한 전용 API를 배우지 않고도, 익숙한 표준 리눅스 명령어를 사용하여 스위치의 L2 기능을 설정할 수 있음을 의미합니다.예를 들어, bridge 유틸리티를 사용하여 VLAN을 생성하고 포트를 할당하는 작업은 다음과 같이 간단하게 수행할 수 있습니다.Bash# eth0, eth1 포트를 포함하는 br0 브리지 생성
ip link add name br0 type bridge
ip link set dev eth0 master br0
ip link set dev eth1 master br0
ip link set dev br0 up
ip link set dev eth0 up
ip link set dev eth1 up

# eth1 포트를 VLAN 10 (태그됨)과 VLAN 20 (태그됨)의 멤버로 설정
bridge vlan add vid 10 dev eth1
bridge vlan add vid 20 dev eth1
이러한 접근 방식은 리눅스 네트워킹에 익숙한 개발자들의 진입 장벽을 크게 낮춰줍니다.6.3. 고급 프로그래밍 제어: MESA APIswitchdev가 일반적인 L2 스위칭 작업을 위한 편리한 인터페이스를 제공하지만, 하드웨어의 모든 세부 기능(예: 정교한 TSN 큐잉, 프레임 선점, 하드웨어 오프로드 엔진 제어)에 접근하기에는 한계가 있을 수 있습니다. 이러한 고급 제어가 필요한 전력 사용자(power user)를 위해 Microchip은 MESA (Microchip Ethernet Switch API) 라는 C 기반의 사용자 공간 라이브러리를 제공합니다.5MESA API는 스위치 하드웨어의 모든 레지스터와 기능을 직접 제어할 수 있는 포괄적인 함수 세트를 제공합니다.12 개발자는 애플리케이션에서 MESA 라이브러리를 링크하여, switchdev가 지원하지 않는 하드웨어 고유의 고급 기능을 프로그래밍 방식으로 완벽하게 제어할 수 있습니다. 따라서 개발 전략은 일반적으로 switchdev로 시작하여 기본 기능을 구현하고, 필요한 경우에만 MESA API를 사용하여 특정 고급 기능을 구현하는 하이브리드 접근 방식을 취하는 것이 효율적입니다.6.4. LAN969x를 위한 프로세스 조정본 보고서에서 설명한 전체 개발 프로세스(BSP 다운로드, Buildroot 설정, U-Boot를 통한 플래싱)는 LAN969x 제품군에도 거의 동일하게 적용됩니다. 가장 중요한 차이점은 빌드 설정 단계에서 올바른 defconfig 파일을 선택하는 것입니다.LAN969x 보드를 위해 빌드할 때는 make 명령에 해당 보드와 CPU(Arm Cortex-A53)에 맞는 defconfig 파일(예: lan969x_standalone_defconfig)을 지정해야 합니다. 이렇게 하면 Buildroot는 LAN969x 하드웨어에 맞는 올바른 TF-A 바이너리, U-Boot, 리눅스 커널, 그리고 디바이스 트리 블롭(DTB)을 자동으로 선택하여 빌드합니다. 이 한 가지 변경만으로 LAN969x 플랫폼을 위한 맞춤형 리눅스 이미지를 생성할 수 있습니다.결론Microchip의 LAN966x 및 LAN969x 개발 보드는 내장된 Arm CPU와 eMMC 플래시 메모리를 기반으로 독립적인 임베디드 리눅스 시스템을 구동할 수 있는 강력하고 유연한 플랫폼입니다. 본 보고서는 이들 보드에 리눅스 시스템을 배포하는 과정이 단순한 '설치'가 아닌, 호스트 PC에서 시스템 이미지를 '빌드'하고 이를 타겟 보드에 '플래싱'하는 전문적인 임베디드 개발 워크플로우임을 명확히 하였습니다.핵심적인 절차는 Microchip이 제공하는 Buildroot 기반의 BSP를 사용하여 시작됩니다. 개발자는 menuconfig를 통해 원하는 시스템 구성을 손쉽게 선택하고, 단일 make 명령으로 크로스 컴파일 툴체인부터 커널, 루트 파일 시스템에 이르는 전체 시스템 이미지를 자동화하여 빌드할 수 있습니다. 생성된 이미지는 개발 중에는 U-Boot와 TFTP를 이용해 신속하게 업데이트할 수 있으며, 시스템 부팅에 문제가 발생했을 경우에는 TF-A UART 모니터와 웹 기반 복구 도구를 통해 안정적으로 복원할 수 있는 이중의 안전장치가 마련되어 있습니다.또한, Microchip은 표준 리눅스 switchdev 인터페이스와 포괄적인 MESA API를 모두 지원함으로써, 개발자가 친숙한 도구로 빠르게 개발을 시작하고 필요에 따라 하드웨어의 모든 성능을 끌어낼 수 있는 이중의 소프트웨어 전략을 제공합니다. LAN9662에서 LAN969x로의 확장 경로 역시 공통된 BSP와 개발 프로세스를 통해 원활하게 이루어지므로, 개발자는 초기 투자를 보호하며 제품 라인을 확장해 나갈 수 있습니다.결론적으로, 사용자의 질문에 대한 답변은 명확합니다. LAN9662 개발 보드는 자체 eMMC를 탑재하고 있으며, 리눅스 배포는 본 보고서에서 상세히 기술한 빌드 및 플래싱 절차를 통해 이루어집니다. 이 가이드를 통해 개발자는 Microchip의 TSN 스위치 SoC가 제공하는 강력한 기능을 활용하여 차세대 산업 및 자동차 네트워킹 애플리케이션을 성공적으로 개발하는 데 필요한 모든 기술적 토대를 갖추게 될 것입니다.
